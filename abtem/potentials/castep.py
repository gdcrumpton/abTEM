"""Module to handle the electrostatic potential obtained from the DFT software CASTEP"""

import numpy as np

from ase.calculators.castep import Castep
from abtem.potentials.gpaw import GPAWPotential
from abtem.potentials.charge_density import ChargeDensityPotential
from abtem.potentials.iam import Potential, PotentialArray, _PotentialBuilder

from typing import TYPE_CHECKING, Any, List, Tuple, Union

class CASTEPPotential(ChargeDensityPotential):
    """
    Uses the existing 'ChargeDensityPotential' class  as a base to add CASTEP-specific functionality.

    Args:
        atoms : Atoms or FrozenPhonons
            Atomic configuration(s) used in the independent atom model for calculating the electrostatic potential(s).
        charge_density : np.ndarray
            Charge density as a 3D NumPy array [electrons / Å^3].
        gpts : one or two int, optional
            Number of grid points in `x` and `y` describing each slice of the potential calculated by specifying either `sampling` or `gpts`.
        sampling : one or two float, optional
            Sampling of the potential in `x` and `y` [1 / Å] calculated by specifying either `sampling` or `gpts`.
        slice_thickness : float or sequence of float, optional
            Thickness of the potential slices [Å] (default is 0.5 Å). If given as a float, the number of slices are calculated by dividing the
            slice thickness into the `z`-height of the cell.
            The slice thickness may be given as a sequence of values for each slice, in which case an error will be thrown
            if the sum of slice thicknesses is not equal to the height of the atoms.
        exit_planes : int or tuple of int, optional
            The `exit_planes` argument can be used to calculate thickness series.
            Providing `exit_planes` as a tuple of int indicates that the tuple contains the slice indices after which an
            exit plane is desired, and hence during a multislice simulation a measurement is created. If `exit_planes` is
            an integer, a measurement will be collected every `exit_planes` number of slices.
        plane : str or two tuples of three float, optional
            The plane relative to the provided atoms mapped to the `xy` plane of the potential, i.e. the propagation direction will be
            perpendicular to the provided plane. If str, must be a concatenation of two of 'x', 'y' and 'z';
            the default value 'xy' indicates that potential slices are cuts parallel to the 'xy'-plane.
            The plane may also be specified with two arbitrary 3D vectors, which are mapped to the `x` and `y` directions of
            the potential, respectively. The length of the vectors has no influence. If the vectors are not perpendicular,
            the second vector is rotated in the plane to become perpendicular to the first. A value of
            ((1., 0., 0.), (0., 1., 0.)) is equivalent to 'xy'.
        origin : three float, optional
            The origin relative to the provided atoms mapped to the origin of the potential. This is equivalent to translating
            the atoms.
            The default is (0., 0., 0.).
        box : three float, optional
            The extent of the potential in `x`, `y` and `z`. If not given this is determined from the atoms. If the box size does
            not match an integer number of the atoms' cell, an affine transformation may be necessary to preserve
            periodicity, determined by the `periodic` keyword.
        periodic : bool, True
            If a transformation of the atomic structure is required, `periodic` determines how the atomic structure is
            transformed. If True, the periodicity of the atoms is preserved, which may require applying a small affine
            transformation to the atoms. If False, the transformed potential is effectively cut out of a larger repeated
            potential, which may not preserve periodicity.
        device : str, optional
            The device used for calculating the potential. The default is determined by the user configuration file.
    """

    @classmethod
    def from_pot_fmt(self, path: str):
        """
        Reads in the formatted electron potential from a '.pot_fmt' file generated by CASTEP.

        Args:
            path : string
                Path to the file location.

        Returns:
            potential : np.ndarray
                that can be read into the 'charge_density' input.
        """

        pot_fmt_file = path

        try:
            f=open(pot_fmt_file)

        except FileNotFoundError:
            raise FileNotFoundError()

        for line in f:
            l=line.split()
            if len(l)!=0 and l[-1]=='<a,b,c>':
                potential_fmt = np.zeros((int(l[0]), int(l[1]), int(l[2])))
            if len(l)==4:
                potential_fmt[int(l[0])-1,int(l[1])-1,int(l[2])-1]=-float(l[3])

        f.close()
        return potential_fmt
    
    @classmethod
    def from_pot1d(self, path: str):
        """
        Reads in the averaged electron potential from a '.dat' file generated by the tool 'pot1d' bundled with CASTEP.

        Args:
            path : string
                Path to the file location.

        Returns:
            potential_array : np.ndarray
                that can be read into the 'charge_density' input.
        """

        pot_file = path

        try:
            f=open(pot_file)

        except FileNotFoundError:
            raise FileNotFoundError()

        for line in f:
            l=line.split()
            #print(l)
            if len(l)==6 and l[2]=='x':
                grid=[int(l[1]),int(l[3]),int(l[5])]
                potential_fmt = np.ones(grid)
            if l[0]!='#':
                x_ind = int( (float(l[0]) * grid[0]) - 1 )
                y_ind = int( (float(l[1]) * grid[1]) - 1 )
                z_ind = int( (float(l[2]) * grid[2]) - 1 )
                potential_fmt[x_ind,y_ind,z_ind] = float(l[3])

        f.close()
        return potential_fmt
